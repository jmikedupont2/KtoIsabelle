20

Liyi Li and Elsa L. Gunter

A

Appendix

A.1

An Example of K

An Example – IMP. We ﬁrst brieﬂy introduce an example K speciﬁcation, IMP
(Fig. 6), in the FAST form, to highlight the features of deﬁning a language in
K. The ﬁgure contains the IMP speciﬁcation with most of its syntax and some
semantic deﬁnitions, and we assume in IMP that all program variables are heap
ones that can be shared through diﬀerent threads.

Syntax
syntax Exp ::= Var | Int | Exp / Exp [strict] | ...
syntax KResult ::= Int | Bool
syntax BExp ::= Bool | Exp < Exp [strict] | BExp && BExp [strict] | ...
syntax Stmt ::= Bloc | Var := Exp [strict(2)] | if (BExp) Bloc Bloc [strict(1)]
| while (BExp) Bloc | Stmt ; Stmt | Var := thread(Stmt)
syntax Bloc ::= {} | {Stmt} syntax Prog ::= int Vars ; Stmt syntax Vars ::= list{Var, ","}
Conﬁguration
�
�
���0 ::Int� key �$pgm::Prog� k �.Map� env � thread∗ � threads
T
�0� count �.Map� heap �SetItem(0)� keys
Rules
(a) �(x ::Var ⇒ e) ···� k �··· x �→ n ···� env �··· n �→ e ···� heap (b) x ::Int / y::Int ⇒ x /Int y when y �=0

�(int (x , xs ⇒ xs) ; _) ···� k
�··· �(x := thread(t) ⇒ .K) ···� k �M ⇒ M [n/x ]� env ···� thread
�··· x �→ n ···� env
(d) (.Bag ⇒ �··· �t� k �M � env �fresh(S , 0)� key ···� thread )
�M ⇒ M [ 0 /n]� heap
�··· n �→ (_ ⇒ fresh(S , 0)) ···� heap �S � keys
�n ⇒ n +Int 1� count
(e) (�··· �key� key �.K� k ···� thread ⇒ .Bag) �S ⇒ S \{key}� keys
Function and Function Rules
syntax Int ::= fresh(Set , Int) [function]
(f) fresh(.Set, n) ⇒ n +Int 1
(g) fresh(SetItem(n::Int) S , m) ⇒ fresh(S , n) when m <Int n
(i) fresh(SetItem(n::Int) S , m) ⇒ fresh(S , m) when m >=Int n
Heating/Cooling Rule Example
(heat)x / y � tl ⇒ x � � / y � tl when ¬isKResult(x ) (cool)v ::KResult � � / y � tl ⇒ v / y � tl
Expanded
Conﬁguration Rule
�
�
C1 ::Bag ���x � κ� k �ρ1 , x �→ n, ρ2 � env C2 ::Bag� thread � threads
T
�ρ3 , n �→ e, ρ4 � heap
⇒�
(j)
�
C1 ::Bag ���e � κ� k �ρ1 , x �→ n, ρ2 � env C2 ::Bag� thread � threads
T
�ρ3 , n �→ e, ρ4 � heap
An Example Execution In IMP
Program: int x ; x := 1

(c)

Conﬁguration After One�Step (Rule
(c)):
Initial
Conﬁguration: �
�
�
� ��
� ���
�
�0� key �.Map� env
�0� key �x �→0� env
thread
threads
thread
threads
�int x ; x := 1� k
�int .Ids ; x := 1� k
T
T
�0� count �.Map� heap �SetItem(0)� keys
�1� count �0�→0� heap �SetItem(0)� keys

Fig. 6: A Summary of K by IMP
Syntax in a K Theory. In K, the keyword syntax introduces a ﬁnite set of
syntactic deﬁnitions, separated by "|", such as the deﬁnition of the sort Exp.
Each syntactic deﬁnition is a list of names. The names in Sans Serif font are
non-terminals (sorts), while the names in TT font are terminals. A syntactic deﬁnition (e.g. Exp ::= Var) introducing only a singleton sort deﬁnes a relation that
subsorts the singleton sort (Var) to the target sort (Exp). The deﬁnition that
subsorts sorts to KResult deﬁnes the evaluation result sorts in a speciﬁcation.

A Complete Semantics of K and Its Translation to Isabelle

21

Other kinds of syntactic deﬁnitions introduce user deﬁned terms that express
rules and programs. Every "real" syntactic deﬁnition (not subsorting) creates a
preﬁx AST format like KLabel (KList ), where the KLabel term acts as a constructor automatically generated by the terminals and the structure of the deﬁnition,
and the KList term is the argument list generated from the non-terminals of
the deﬁnition. The syntax deﬁnitions in a K theory are compiled by the IsaK
static semantics into a sort set, a symbol table, a subsort relation and several
heating/cooling rules as inputs for the IsaK dynamic semantics (Sec. 3).
K Attributes in Syntax in FAST are Equal to Semantic Rules in BAST. K
allows users to deﬁne attributes in a syntactic deﬁnition (written in brackets e.g.
[strict], in Fig. 6), some of which have semantic meanings. For example, the
strict(2) attribute (in the deﬁnition: Var := Exp [strict(2)]) is compiled to
a BAST theory that generates a pair of heating/cooling rules for the second nonterminal position of the term created by the deﬁnition. The [strict] attribute
without any numbers indicates there is a pair of heating/cooling rules generated
for each non-terminal position in the deﬁnition. We show an example pair of
heating/cooling rules for the ﬁrst non-terminal position of the "/" operator in
Fig. 6. "�" is a list concatenation operator for connecting the computation
sequence in a k cell, while "�" is a special builtin operation in K representing
the removal of a redex subterm from a term and the creation of a "hole" waiting
to be ﬁlled. The semantics of any heating rule is to break down a term into
subterms and let other semantic rules evaluate them, while the meaning of any
cooling rule is to merge an evaluated subterm to the right position (�) of the
term.
K Conﬁgurations. Allowing users to deﬁne a global initial conﬁguration for
every K theory is a key K feature. The initial conﬁguration of a speciﬁcation
is an algebraic structure of the program states, which are organized as nested,
labeled cells, in XML formats that hold semantic information, including the
program itself (preﬁxed by the $ operator in Fig. 6). While the order of cells in a
conﬁguration is irrelevant, the contextual relations between cells are relevant and
must be preserved by rules deﬁned by users and subsequently "completely ﬁlled"
in the compilation step in K according to the conﬁguration. In a trace evaluation,
each step of the computations should produce a result state (conﬁguration) that
"matches" the structure of the initial conﬁguration, meaning that the names,
sorts, and structural relations of the cells are preserved in the result conﬁguration
and initial conﬁguration. Leaf cells represent pieces of the program state, like
computation stacks or continuations (e.g., k), environments (e.g., env), heaps
(e.g., heap), etc. The content of each cell in an initial conﬁguration has dual
roles: it establishes the initial value of the computation and also deﬁnes the sort
of the cell content. For example, the key cell in the IMP conﬁguration (Fig. 6) is
deﬁned as 0 and sort Int; during an evaluation, the cell’s initial value is 0, and
in every state of the evaluation, its content has a sort that subsorts to Int. The
last part of Fig. 6 provides an example program in IMP combined with its initial
conﬁguration. After evaluating the initial conﬁguration by rule (c) in IMP, the

22

Liyi Li and Elsa L. Gunter

contents of several cells are updated, but the structure relations and sorts of the
cells are preserved during the evaluation.
Semantic Rules in a K Theory and Their Compilation in BAST. Fig. 6 also
contains a set of IMP rules. The simplest form of the rules, such as rule (b),
describe behaviors that can happen in the ﬁrst element position in a k cell (representing the computation list in a thread), without mentioning any cells or the
tail of the computation list of the k cell. A little more complicated form of rules,
such as (heat) and (cool), mention the tail of the computation list (connected
by "�"). They describe behaviors that can happen in a k cell, especially the
relationships among diﬀerent positions in the computation list. In the BAST
format, these two kinds of rules are compiled to the same form (K rules). The
most complicated form of rules, such as rule (a), are typical conﬁguration rules
in K, and they describe interactions among diﬀerent device/state components
in a system. For example, rule (a) reads from a value in the main memory (the
heap cell) for a variable in the k cell through a local stack (env). The “···” operator
in these rules represents portions of cells that are irrelevant. This unconventional
notation allows users to write concise semantic rules.
In this paper, we focus on the dynamic semantics of K. All these unconventional conﬁguration rules are assumed to be compiled to a standard form
(BAST) by the IsaK static semantics [27], and the dynamic semantics deﬁnitions are based on the compiled format. For example, rule (a) is compiled to rule
(j). To translate (a) to (j), we would need to add the cells T, thread, threads in
rule (j), variables C1 and C2 , and their sorts (Bag), to indicate the irrelevant
program state pieces. Computations in the k cell would be separated by "�",
which is now observable in (j). The κ and ρ1 , ρ2 , ρ3 , and ρ4 would ﬁll in the
place corresponding to the “···” in rule (a).
In K, conﬁguration rules are also powerful enough to manipulate language
device resources. For example, rules (d) and (e) create or ﬁnish a thread by
adding or deleting a thread cell. These are handled by rewriting an empty Bag
place (.Bag) to a new cell thread (rule (d)), or by rewriting a thread cell to an
empty place (rule (e)). In K, this is allowed only if the speciﬁc cell in the initial
conﬁguration (e.g. the conﬁguration in Fig. 6) is marked as "∗".
K also allows users to write equational rules, named function rules. The
format is like the fresh deﬁnition in Fig. 6. Its syntactic deﬁnition (fresh) is
labeled by an attribute function, and then the rules whose left-hand top-most
constructor is the same as the KLabel ’s term syntactic deﬁnition are recognized
by K to be the function rules under the function deﬁnition. The left-hand-side
of a valid function rule has argument sorts that subsort to the argument sorts
deﬁned in the function deﬁnition, and the target sort of the right-hand-side
subsorts to the target sort of the deﬁnition. All of these rules are compiled to
BAST (described in Sec. 3.1) as the input for the IsaK dynamic semantics.

A Complete Semantics of K and Its Translation to Isabelle

A.2

IsaK BAST Syntax and Sorts

Domains and Terms
Conﬁg Names
v ∈ CName � BName ∪ {k}
c ∈ KLabel � LName ∪ {klabel, isKResult, ∧, ¬, =}
KLabels (Constructors)
\{lConstr, sConstr, mConstr, bConstr}
k ∈ KItem � KLabel (KList )::s | �::s
KItem Terms
k ∈ K � KItem list
Associative and Identitive KItem Sequences
kl ∈ KList � K list
Associative and Identitive K Sequences
ListItem � lConstr(K )
Singleton List Terms
l ∈ ListItem � � ListItem | KLabel (KList )::List
List Terms With Funs
l ∈ List � ListItem � list
Associative and Identitive List Terms
SetItem � sConstr(K )
Singleton Set Terms
S ∈ SetItem � � SetItem | KLabel (KList )::Set
Set Terms With Funs
S ∈ Set � SetItem � list
Idempotent Set Terms
MapItem � mConstr(K , K )
Singleton Map Terms
M ∈ MapItem � � Map | KLabel (KList )::Map
Map Terms With Funs
M ∈ Map � MapItem � list
Idempotent, and Functional Map Terms
BagItem � bConstr(CName,Term)
Singleton Conﬁgurations
C ∈ Bag � BagItem list
Associative, Commutative, and Identitive Conﬁguration Terms
t ∈ Term � KItem ∪ K ∪ List ∪ Set ∪ Map ∪ Bag
Allowed Terms
Pat � Term
Patterns Exp � Term
Expressions
Transition Rule Syntax
rl ∈ Rule �
KLabel (KList )::s ⇒ KLabel (KList )::s1 when KLabel (KList )::s2
(* KItem Function Rules(s1 � s � KItem ∧ s2 � Bool) *)
| KLabel (KList )::K ⇒ (K | KLabel (KList )::K)when KLabel (KList )::s2
(* K Function Rules(s2 � Bool) *)
| KLabel (KList )::List ⇒ (List | KLabel (KList )::List)
(* List Function Rules(s2 � Bool) *)
when KLabel (KList )::s2
| KLabel (KList )::Set ⇒ (Set | KLabel (KList )::Set)
when KLabel (KList )::s2
(* Set Function Rules(s2 � Bool) *)
| KLabel (KList )::Map ⇒ (Map | KLabel (KList )::Map)
(* Map Function Rules(s2 � Bool) *)
when KLabel (KList )::s2
| K ⇒ K when KLabel (KList )::s2 (* K Transition Rules(s2 � Bool) *)
| Bag ⇒ Bag when KLabel (KList )::s2
(* Conﬁguration Transition Rules(s2 � Bool) *)
IsaK Theory Input
Symbols
Symbol � KLabel | KLabel → Bool
Υ ⊆ Ψ × Ψ list × Symbol × Bool Symbol Table
Subsort Relation: �
Rule Set: Δ ⊆ Rule

Fig. 7: IsaK Syntax in Isabelle (No Meta-Variables)

23

24

Liyi Li and Elsa L. Gunter

We ﬁrst introduce the syntactic formulation of a given IsaK theory in BAST
before we introduce the semantics of evaluating a program for a theory. Syntactically, every IsaK theory is expressed as a tuple of (Ψ, �, Υ, Δ), where Ψ is a
set of sort names and (Ψ, �) is a poset, Υ is a symbol table and Δ is a set of
Rule terms, which will be introduced later in the section. � is a subsort relation
built on pairs of sorts in Ψ . We have restrictions on Ψ and � as follows:
Sorts
SystemSort � {K, KItem, KList, List, Set, Map, Bag}
BuiltinSort � SystemSort ∪ {Bool}
RName ⊆ UsrSort
BuiltinSort ∩ UsrSort = ∅
ResultSort � RName ∪ {Bool}
s ∈ Ψ � UsrSort ∪ BuiltinSort
Sort/Subsort Sat Properties
(Ψ, �) is a poset
� ⊇ (UsrSort × {KItem}) ∪ {(KItem, K)}
∀s1 s2 . s1 ∈ {KList, List, Set, Map, Bag} ∧ s1 � s2 ⇒ s1 = s2

Every sort is disjointly either a user-deﬁned sort (UsrSort ) or a built-in sort
(BuiltinSort ). Each sort in ResultSort is either Bool, or a user-deﬁned sort that can
be the sort of the result of a computation, like Int (see Fig. 6). There are several
restrictions on �. For example, sort K is an upper bound of UsrSort , while KItem
is the supremum of the same set. The elements in {KList, List, Set, Map, Bag} are
incomparable under �; and SystemSorts are not result sorts.
Additionally, in the original K, when a result sort is declared, the sort is
subsorted to a special sort KResult. This formalization causes a problem in the
type (sort) system soundness in K: a term with a result sort can be rewritten to
another result-sorted term, but the position holding the term is deﬁned to hold
one of the sorts but not the other one. For example, assume that x has value
true in the heap, and we want to compute x /1. By applying rules (heat) and
(a) in Fig. 6, the result is the term: true � (�/1). Since true is a KResult
term, we can use rule (cool) in Fig. 6 to rewrite the term to true/1. This term
is clearly ill-typed. In an evaluation in a K theory, this feature makes some rule
applications result in type-errors that cannot make any further evaluations, but
the K type (sort) system cannot detect this error in the theory. In IsaK, we
discard the KResult sort and view the sorts subsorting to KResult as deﬁning
a set of result sorts. We use the predicate isKResult, whose meaning is the
membership of ResultSort . We replace every place in a K theory that describes a
term subsorting to KResult with an isKResult predicate on the term. Thus, the
subsort relation of KResult in a K theory is replaced in IsaK by the checking of a
property on terms by isKResult. For example, the sort enforcement of KResult
in rule (cool) becomes:
v :Exp � � / y � tl ⇒ v / y � tl when isKResult(v)

We now describe IsaK terms through the symbol table Υ . Any term in IsaK
satisﬁes the grammar deﬁned in Isabelle in Fig. 7. The symbol table (Υ ) is a

A Complete Semantics of K and Its Translation to Isabelle

25

translated product of the IsaK static semantics in Sec. 2, and each of its entries
describes a syntactic deﬁnition for a speciﬁc constructor. This is represented as a
tuple of a target sort (s), a list of argument sorts (sl), a set of symbol names (CS)
representing a set of constructors that is either a singleton set of a KLabel term
or set of many KLabel terms (generated from user deﬁned tokens, like variable
names and integers), and a Boolean value (b) indicating if the constructor is
a function constructor. For a given IsaK theory, the constructors (having the
type KLabel ) appearing in the AST tree of a term must be a constructor name
(Symbol ) in an entry of Υ . For a given symbol table entry (s, sl, CS, b), the sort
information for the constructor c ∈ CS is sl → s. A valid term in an IsaK
theory satisﬁes the following deﬁnition.
Deﬁnition 1. Given a symbol table Υ , a term is a valid IsaK term iﬀ every
subterm (having the form c(c1 , ..., cn )::s) appearing in the AST of the term
satisﬁes the following:
– If c1 , ..., cn is an empty list, then s is a supersort of the sort of c in Υ .
– If c1 , ..., cn is not empty, let s�1 , ..., s�n be the argument sorts of c in Υ . Then,
for every term ci in c1 , ..., cn , its sort si is a subsort of s�i , and the sort s is
a supersort of the sort of c in Υ .
K is a language that allows users to deﬁne a speciﬁcation by giving a set
of terms containing meta-variables, and it also allows them to deﬁne a speciﬁc
ground term (without any meta-variable) as a "program" that produces a trace
of the states when executed with the rules deﬁned in the speciﬁcation. An IsaK
theory represents the speciﬁcation, doing so as a tuple of (Ψ, �, Υ, Δ). Δ is a
ﬁnite set of rules, each of which is a Rule term (possibly with meta-variables)
deﬁned in Fig. 7. A "program" for the theory is a Bag ground term.
In Fig. 7, we now describe brieﬂy the grammars that deﬁne the Υ set in an
IsaK theory. The variables appearing on the left (before ∈) range over the sets
on the right. We assume that the name sets (UsrSort , LName, and BName) are
all disjointly unioned with each other. Any term in KItem is a user deﬁned one
allowed in a computation, with the ﬁxed format of a constructor (KLabel ) applied
to a list of arguments (KList ). The operation (::) represents a type enforcement
by giving a sort. It can appear in any term in IsaK, and sometimes we omit
such information in examples.
The � symbol in the KItem deﬁnition in Fig. 7 represents a family of symbols,
one for each sort, each which represents a "hole" in the context term created
when we split a term into context and redex terms, such as the � in Fig. 6
(heat). These symbols are mainly used for K heating/cooling rules. With the
� symbols, the evaluations of a term using heating/cooling rules are the same
as for other rules. In IsaK, there are built-in lists (List ), sets (Set ), and maps
(Map) for users with diﬀerent built-in equational properties (listed in Fig. 7).
Type Bag contains lists (with associative, commutative, and identity equational
properties) of basic program state pieces, named conﬁguration pieces or cells
and having the type BagItem. Each cell contains a cell name (CName) and subconﬁguration components, an example of which the IMP conﬁguration is shown

26

Liyi Li and Elsa L. Gunter

in Fig. 6. In Sec. 2, we introduced how a conﬁguration works. Users need to
deﬁne an initial conﬁguration along with their language speciﬁcation. For every
step of the evaluation of an input program, the result program state obeys the
sort and position relations among the diﬀerent cells in the initial conﬁguration.
One feature in IsaK that is useful for conﬁguration translation (Sec. 4.2) is that
Υ contains entries for all cell names appearing in the initial conﬁguration. In an
IsaK theory, the name of each cell has an entry in Υ that contains a target sort
the same as the sort of the element in the cell in the initial conﬁguration, an
empty argument sort list, a singleton set of the cell name, and a false Boolean
value. For example, cell env has a content of sort Map (Fig. 6), so it has the
entry: (Map, [], {env}, false).
Besides the above syntactic deﬁnitions and restrictions, an IsaK theory also
has other syntactic restrictions that appear in the static translation process
from FAST to BAST (introduced in [27]). For example, all rules (Rule) have
the format: Pat ⇒ Exp when Exp, where the left hand side of ⇒ is the pattern
(Pat ) to match with, and the right hand side of ⇒ is the target expression (Exp)
to rewrite to, provided that the condition expression (Exp) after the keyword
when is satisﬁed. Terms in both types Pat and Exp are IsaK terms (Term), but
they have diﬀerent syntactic restrictions checked by the IsaK static semantics
(Supplement). For example, no term in Pat can have proper sub-terms possessing
function constructors. For a given Rule term, meta-variables can only represent
a term (Termﬀr in Fig. 7).
A.3

Translating Datatypes

For a given IsaK theory Θ = (Ψ, �, Υ, Δ), we ﬁrst translate the tuple (Ψ, �, Υ )
to a pair of a ﬁnite quotient type set and a ﬁnite set of Isabelle proofs (Ω q , Π)
in the translated Isabelle theory (Ξ), such that all relations in � are invisible in
Ξ, but their functionality is merged in Ω q . The way to achieve this is to utilize
Isabelle quotient types: we ﬁrst translate the IsaK datatype tuples (Ψ, �, Υ ) to
a ﬁnite Isabelle datatype set Ω by explicitly coercing every pair in �, and then
translate Ω to a quotient type set Ω q with a ﬁnite set of proofs (Π), one for each
target sort in Ω q , to show that each quotient type in Ω q deﬁnes an equivalence
relation over all of the syntax deﬁned in Ω. We describe the two processes below.
The Translation from K Datatypes to Isabelle Datatypes. The translation step
from the tuple (Ψ, �, Υ ) to an Isabelle datatype set Ω has two parts: adding
builtin datatypes (corresponding to terms in BuiltinSort in Sec. 3.1) and translating user deﬁned datatypes (corresponding to terms in UsrSort in Sec. 3.1). The
two parts for translated result of the IsaK theory (IMP) syntax in Fig. 2 are
shown Fig. 8. The builtin datatypes that are additionally generated in Fig. 8 are
in a one-to-one correspondence with the datatypes in IsaK in Fig. 7, except the
datatypes KLabel /KList , which represent constructors and their arguments in K
and are absorbed into diﬀerent datatypes in Isabelle. We implement the builtin
K , List , Set , Map, and Bag datatypes as type synonyms for Isabelle builtin lists
of corresponding singleton item datatypes, e.g. KItem list for K . The reason to
translate these builtin datatypes to Isabelle builtin list structures is to capture

A Complete Semantics of K and Its Translation to Isabelle

27

Builtins
datatype KItem = s1 _KItem s1 |...| sn _KItem sn s1 , ..., sn ∈ UsrSort
type_synonym K = KItem list
datatype SetItem = SConstr K type_synonym Set = SetItem list
datatype ListItem = LConstr K type_synonym List = ListItem list
datatype BagItem = BagC CName Bag | MapC CName Map | SetC CName Set
| ListC CName List | KC CName K
type_synonym Bag = BagItem list datatype MapItem = MConstr K K
type_synonym Map = MapItem list
Translated Syntax
datatype Exp = Exp_Hole | Var_Exp Var | Int_Exp Int | Div Exp Exp | ...
datatype BExp = BExp_Hole | Bool_Exp Bool | Less Exp Exp | And Exp Exp | ...
datatype Stmt = Stmt_Hole | Bloc_Stmt Bloc | Assign Var Exp
| If BExp Bloc Bloc | While BExp Bloc | Seq Stmt Stmt | Thread Var Stmt
datatype Bloc = Empty | Single Stmt datatype Prog = Prog Vars Stmt
datatypeVars = VarUnit | VarCons Var Vars

Fig. 8: Example of Datatype Translation (IMP)

the aspect that some builtin datatypes have implicit equational properties associated with them (listed in Fig. 7). By representing these datatypes as Isabelle
list structures and representing a connection operation in IsaK (e.g. the set concatenation operation in K) as an Isabelle list concatenation operation (@), we
are able to capture the implicit associative and identity equational properties on
the these datatypes without extra cares. The other implicit equational properties
are dealt with when translating datatypes to quotient types.
The translation of user deﬁned datatypes in K to Isabelle is done by adding
explicit coercions for all subsort relation pairs in �, e.g. the constructor Var_Exp
coerces a term in Var to Exp, except that all function constructs (e.g. fresh in
Fig. 6), which are translated directly into inductive relations without having
datatype deﬁnitions in Isabelle (Sec. 4.2). Additionally, Since every user deﬁned
sort (s) is a subsort of KItem, we implement KItem as the union of all coercions of
user deﬁned sorts by adding a constructor for each one (s) of them as: s_KItem.
We also add an extra constructor (like Exp_Hole) for each sort that contains some
syntactic deﬁnitions with [strict] attributes to represent the � term in IsaK
(Sec. 3). In IMP (Fig. 8), for example, we generate extra "hole" constructs for the
types Exp, BExp, and Stmt , but other user deﬁned sorts have no such construct
because they do not have a deﬁnition with a [strict] attribute (Fig. 6).
From Datatypes to Quotient Types. Here we translate the Isabelle datatype
set Ω to the quotient type set Ω q with a set of proofs Π. A quotient type
represents a set of terms, with a ﬁxed target sort, whose elements are equivalence
classes that are partitioned the whole term domain by a given set of equations.
Some datatypes in Ω are only translated to "trivial" quotient types, meaning a
quotient type with the Isabelle’s builtin = operation as its equivalence relation.

28

Liyi Li and Elsa L. Gunter

�− � (� \{(s1 , s2 )|s1 = K ∨ s2 = K}) ∪ {(K, K)} (a) quotient_type int q = "int " / "(=)" by (rule identity_equivp)
inductive comeq where
com: "comeq (x@y) (y@x)"
quotient_type Bag q = "Bag " / "comeq"
| recur: "comeq u v =⇒ comeq (x@u@y) (x@v@y)"
...(f )...
(b)
| rlx: "comeq x x "
done
| sym: "comeq x y =⇒ comeq y x "
| trans: "�comeq x y;comeq y z � =⇒ comeq x z "
quotient_type Set q = "Set " / "idmeq"
inductive idmeq where
...(f )...
idem: "set x = set y =⇒ idmeq x y
done
(c) | rlx: "idmeq x x "
quotient_type Map q = "Map" / "idmeq"
| sym: "idmeq x y =⇒ idmeq y x "
...(f )...
| trans: "�idmeq x y;idmeq y z � =⇒ idmeq x z "
done
fun s1 _eqfun where
s1 "s1 _eqfun (s2 _s1 (s3 _s2 x)) (s3 _s1 y) = s1 _eqfun x y"
...
(d)
inductive s1 _eq where
s2 base: "s1 _eqfun x y =⇒ s1 _eq x y
| rlx: "s1 _eq x x "
| sym: "s1 _eq x y =⇒ s1 _eq y x "
�−
| trans: "�s1 _eq x y;s1 _eq y z � =⇒ s1 _eq x z "
s3 quotient_type s1 q = "s1 " / "s1 _eq"
...
fun s1 _eqfun where
s1
"s1 _eqfun (s3 _s1 (s4 _s3 x)) (s2 _s1 (s4 _s2 y)) = s1 _eqfun x y"
...
(e)
inductive s1 _eq where
s3
s2 base: "s1 _eqfun x y =⇒ s1 _eq x y
| rlx: "s1 _eq x x "
| sym: "s1 _eq x y =⇒ s1 _eq y x "
�−
| trans: "�s1 _eq x y;s1 _eq y z � =⇒ s1 _eq x z "
s4
quotient_type s1 q = "s1 " / "s1 _eq"
...
apply (simp add:equivp_reflp_symp_transp) apply (rule conjI)
apply (rule conjI)
apply (simp add:symp_def,clarsimp)
apply (simp add:sym)
(f ) apply (simp add:reflp_def)
apply (simp add:rlx)
apply (simp add:transp_def,clarsimp)
(∗ next on the right ∗)
apply (simp add:trans)

Fig. 9: Example of Translation to Quotient Types

The translation of Int to a quotient type in (a) (Fig. 8) is one example, and we
just need the one-line proof "rule identity_equivp" for such a case.
For any datatype subset of Ω indexed by a speciﬁc target sort, there are
four cases necessarily needing non-trivial quotient type translations. The general
strategy for translating non-trivial cases is to deﬁne inductive relations to capture
equivalence relations deﬁned for the quotient types, and to prove that these really
are such relations. Among these inductive equivalence relation deﬁnitions for
translating non-trivial cases, we deﬁne the rlx, sym, and trans rules to ensure
that the deﬁnitions are equivalence relations, such as the ones in (b) and (c) in
Fig. 9, which capture the implicit equational properties (only the communicative
and idempotent properties) hiding in the builtin terms Bag , Map and Set . Case
(b) deals with the communicative equational property in Bag terms. The com
and recur rules capture the communicative relations among the elements in a
BagItem list (which is a Bag term) precisely. In the case, the right ﬁgure shows

A Complete Semantics of K and Its Translation to Isabelle

29

how a quotient type with a proof is deﬁned in Isabelle, and the proof content is
in (f ) in Fig. 9. In fact, (f ) is the generalized proof for every non-trivial case
quotient type proof in the translation. Case (c) provides an inductive relation
capturing the idempotent equational property in the Set and Map terms. The
rule idem deﬁnes the core equivalence property of two lists of SetItem or MapItem
elements: two lists are equivalent if the set translations of the two lists are the
same. As we stated in Fig. 7, Map terms must also be functional to be valid
in a conﬁguration. We incorporate the functional property as a transition rule
in Sec. 4.2. Cases (d) and (e) in Fig. 9 capture all necessary non-trivial cases
translating from datatypes to quotient types for user deﬁned sorts/datatypes,
whose general concept has been described in [25]. The process is to identify
the possibly equivalent terms due to the removal of the subsort relation and
explicit coercions when translating an order-sorted algebra to a many-sorted
one. We ﬁrst manipulate the input subsort relation � to be the deﬁnition of
�− in Fig. 9 by eliminating all subsorts related to sort K. Here is the reason.
The only immediate subsort of sort K in � is the sort KItem, and users are not
allowed to subsort other sorts to K. The only equivalent terms caused by explicit
coercing KItem to K are those recognizing a KItem term as a singleton K term,
which will be translated properly at the stage of translating terms and rules
(Sec. 4.2). Cases (d) (and (e)) in Fig. 9 describe how we generate quotient types
when a "line" (and a "diamond") structure is presented in the subsort relation
�− . For the terms in the sort marked as yellow in cases (d) and (e), we generate
a function, a relation, and a proof to capture capture the equivalence relations
among these terms. Case (d) describes a possible "line" structure in �− , where
three diﬀerent sorts s1 , s2 , and s3 have subsort relations in a line, like the left
graph in (d). In this case, if the terms in s1 have a combined explicit coercion
(s2 _s1 (s3 _s2 x)), it is equivalent to a term being directly coerced from s3 ,
as (s3 _s1 y), provided that the terms x and y are also equivalent. In Isabelle,
we generate a function s1 _eqfun to capture the above description. The ... part
contains other trivial cases for two terms in s1 . Sometimes, if a target sort s1
contains other possible subsort relations ﬁtting patterns in (d) and (e), we also
need to take care of those situations in s1 _eqfun. The inductive relation s1 _eq
is a trivial equivalence relation wrapper for s1 _eqfun. We can then build the
quotient type s1 q based on s1 _eq with the same proof as (f ). Case (e) describes
a possible "diamond" structure in �− . In four diﬀerent sorts s1 , s2 , s3 , and s4 ,
the sorts s1 , s2 , and s4 have subsort relations, while the sorts s1 , s3 , and s4 also
have subsort relations. In this case, the coercions using diﬀerent paths from s 4 to
s1 are all equivalent. We implement case (e) by the function s1 _eqfun, relation
s1 _eq and quotient type sq1 , in the same manner for case (d).
A.4

Translating K Terms and Rules

Here we translate the IsaK terms and rules. For an IsaK theory (Ψ, �, Υ, Δ),
the translation algorithm for user deﬁned terms simply walks down the ASTs of
the terms by adding explicit coercions according to the syntactic translations in
Sec. 4.1. The only tricky aspect is that the terms translated in Isabelle have no

30

Liyi Li and Elsa L. Gunter

KLabel or KList subterms. The translation of builtin terms can be summarized as
the translation of IsaK conﬁgurations to Isabelle ones. The translation algorithm
is straightforward with keeping an eye on the symbol table Υ to determine the
sort for every cell in the conﬁguration.

(a) BagC T [BagC threads [BagC thread [KC key [Int_KItem 0],
KC k [Prog (VarCons x VarUnit) (Assign x (Int_Exp 1))],MapC env []]], KC count [Int_KItem 1],
MapC heap [MConstr [Int_KItem 0] [Int_KItem 0]], SetC keys [SConstr [Int_KItem 0]]]
(b) c(kl)::s ⇒ c1 (kl1 )::s1 when c2 (kl2 )::s2 ϕ1 ∧ ... ∧ ϕn =⇒ c_ind t1 t2
inductive fresh_ind where
�m < n; fresh_ind (S , n) x1 �
fresh(SetItem(n::Int) S , m)
=⇒ fresh_ind ([SConstr [Int_KItem n]@S , m) x1
⇒ fresh(S , n) when m <Int n
...
...
definition fresh where
"fresh e = (SOME x . fresh_ind e x)"
(c) t1 ⇒ t2 when c(kl)::s
ϕ1 ∧ ... ∧ ϕn =⇒ τ _rule t3 t4
inductive k_rule where
...
�t = abs_K((Exp_KItem v)#((Div x Exp_Hole)#tl));
v :Exp � � / y � tl ⇒ v / y � tl when isKResult(v)
isKResult((Exp_KItems v)); t� = abs_K((Div x v)#tl)�
=⇒ k_rule t t�
...
(d) inductive bag_rule where
�locate (abs_Bag C) = (C � , t); k_rule (abs_K t) t� � =⇒ bag_rule C (abs_Bag C � [rep_K t� ])
| �C = abs_Bag (BagC T ([BagC threads [BagC thread [KC key [key],KC k []]@xs]@ys, SetC keys S ]@zs));
C � = abs_Bag (BagC T ([BagC threads ys, SetC keys (SetCut(S , [SetConstr [Int_KItem key]]))]@zs))�
=⇒ bag_rule C C �
...
(e) inductive top where
�is_map_fun C1 ; C = abs_Bag C1 ; bag_rule C C � � =⇒ top C (Some C � )
| �¬is_map_fun C1 ; C = abs_Bag C1 � =⇒ top C None

Fig. 10: Examples of the Translation of Terms and Rules

Fig. 10 (a) is a translated term from the initial conﬁguration in Fig. 6; its
datatype deﬁnition is in Fig. 8. To determine the constructor for cell T (BagC
or MapC, etc), we look at Υ for the target sort of T. Since it has sort Bag, we
add the constructor BagC for cell T. If the target sort of a cell (e.g. key) subsorts
to K, we give the cell a constructor KC, and turn the cell content to a singleton
sort K term, such as the translated term [Int_KItem 0] in the cell key. One
of the beneﬁts of using TransK instead of IsaK in Isabelle is its signiﬁcantly
shorter representations of terms. In fact, the initial conﬁguration in (a) (Fig. 10)
is one-third the length of what it would be if written in IsaK.
Next, we introduce the translation of rules, which is to translate the rule set
Δ to a set of rules Δi , whose elements are all represented as inductive relations
in Isabelle. The translated relations are all quantiﬁer-free with all meta-variables
represented as universally quantiﬁed meta-variables in Isabelle. In Sec. 3, we introduced the IsaK rewriting system by dividing rules into three kinds: function,
K, and conﬁguration rules. The rule translation deals with these rules diﬀerently.
The functional checking step in the common evaluation procedures (Sec. 3.2) is
disregarded from the rule translation here and will be represented as a speciﬁc

A Complete Semantics of K and Its Translation to Isabelle

31

inductive rule to check that every Map term in a conﬁguration is functional in
the latter part of the section.
Translating Function Rules. We ﬁrst investigate the translation of function rules.
Each rule translation is divided into two parts: a translated inductive relation
in Isabelle that captures the meaning of the function rule, and a deﬁnition using
Hilbert’s choice operator to produce the output of the relation. In K, a function
is deﬁned as a syntactic deﬁnition with several function rewrite rules, whose
format is as (b) in Fig. 10. Each function is translated to a single inductive
relation and a deﬁnition using Hilbert’s choice operator. Given a subset of the
symbol table Υ (as Υf ) containing only function constructs, and a subset of Δ
(as Δf ) containing only function rules, we produce a set of inductive relations in
Isabelle as Δif containing the translated results of Δf . In K, applying a function
rule rlf on a given term t results in two possibilities: either it terminates and
returns the resultant term t� , or it never terminates due to endlessly rewriting the
condition expression of rlf . Moreover, in all K tools, function rule applications
are implemented as a transition step in a big-step semantic format, where the
function application step produces either an inﬁnite sequence of function rule
applications or the result of a ﬁnite sequence of function rules being applied to
the input term. In TransK, we keep this strategy and translate function rules
as inductive relations using a big-step semantic format.
Fig. 10 (b) describes the translation of a function rule to an Isabelle inductive
relation with an example (based on the fresh function in Fig. 6). For each
function label c, we select all function rules belonging to it in Δf (having the
rule pattern of the top-most constructor being c). We generate an inductive
relation header (c_ind) in Isabelle (e.g. the fresh_ind header in Fig. 10 (b)) for
the group of rules belonging to c. For a single rule rlc for the function label c, its
translation results in an inductive relation case in the relation c_ind, where the
term t1 is the translated term describing the input pattern arguments of rlc (the
kl part). An example of such a pattern is the (SetItem(n:Int) S , m) part of
the fresh function rule; it is translated to ([SConstr [Int_KItem n]@S , m)
in (b). The term t2 is the translation of the target expression of rlc . Sometimes
we need to call rlc or other functions recursively, so we might need to use a
generated variable (x1 in Fig. 10), and generate an equality in the condition of
the inductive rule. The conditions ϕ1 , ..., ϕn contains not only the translation
of the condition expression of rlc (the m <Int n part), but also the equities
to access the recursive or other function calls. The handling of x1 above is one
example. If the rule expression (the t2 and c1 (kl1 )::s1 parts in (b)) contains other
mutually recursive function calls, they also need to be translated into variable
terms in t2 , with equities as some conditions in ϕ1 , ..., ϕn . After we construct the
inductive relation for a K function (or inductive relations for a set of mutually
recursive functions), we create a deﬁnition with the Hilbert’s choice operator
SOME to force the inductive relation to output terms with the type matching the
target sort of the K function as the Isabelle deﬁnition in (b), so that we can use
the name of the function in a conﬁguration or other rule expressions directly.

32

Liyi Li and Elsa L. Gunter

Translating K and Conﬁguration Rules. The general strategies for translating a
K rule or a conﬁguration rule are very similar, as described in Fig. 10 (c). They
are almost the same as translating a function rule, except that t3 and t4 are
mostly translated from the terms t1 and t2 that appear in the K or conﬁguration
rule. The τ in (c) is either k or bag. In (c), we show an example of translating the
cooling rule example in Fig. 6 (actually, the revised of the example in Sec. 3.1)
to an inductive relation case in the inductive relation k_rule. In the translation,
the translated terms t and t� are quotient type terms of sort K . This is why we
use t and t� as variables and then place equities in the conditions in the case to
enforce terms t and t� to be quotient typed terms.
Translating conﬁguration rules is similar to translating K rules, except that
conﬁguration rules are applied to the whole program state (conﬁguration). We
translate all conﬁguration rules in Δ to cases in an inductive relation named
bag_rule, with an additional rule case capturing the applications of K rules.
Fig. 10 (d) shows example rule cases in bag_rule. Given an input conﬁguration
C, the ﬁrst case is to apply a K rule to a k cell in C. We pre-deﬁne a function
locate in the case, along with the translated Isabelle theory, to locate a k cell
in C and split C into a context C[]k and a redex t (the content of the k cell).
Then we apply the corresponding inductive relation k_rule to the quotient type
term of t: (abs_K t), and merge the context and new redex as C[rep_K t� ]k
as the new conﬁguration. abs_K and rep_K are Isabelle functions to get an
actual term from a quotient type term in sort K and vice versa. The second rule
case in (d) is a translation from the (j) example rule in Fig. 6. Similar to the
situation in translating K rules, the input and output conﬁgurations C and C �
are quotient types, and their contents are wrapped in the coercion abs_Bag. Case
(e) in Fig. 10 is the top inductive relation for a translated Isabelle theory. It
implements the functional checking for every Map term in an input conﬁguration
C by a pre-deﬁned function is_map_fun; and if the check is valid, then the
bag_rule relation is allowed to apply to C and to observe one step transition;
otherwise, the system enters an error state (None).
A.5

Type Theorem Proof Sketches based on the Isabelle Proof

In this section, we show proofs for Theorem 1 that is restated below as Theorem 4.
Theorem 4. For a type correct theory (Θ) without anywhere and macro rules,
for any type correct conﬁguration C , evaluating C in IsaK never results in a
type-error.
Proof. Given an IsaK theory (Θ) and an initial conﬁguration C that are typechecked, the proof is based on structure induction on diﬀerent rules applied to
conﬁguration C. There are three possible rule applications:
– If the rule application is a function rule one, for any given conﬁguration C
that is split into a context C[]sf and redex c(kl)::s, a function rule application

A Complete Semantics of K and Its Translation to Isabelle

33

transit the term c(kl)::s into a possible new term t with sort s� , and s� must
subsort to the sort s based on the function rule type correctness (the target
sort of the right-hand-side of a rule must be a subsort of the target sort of the
left-hand-side). Thus, if we plug the term t back into the context C[]sf , the
conﬁguration becomes C[t::s� ]sf . Since s� subsorts to s, the new conﬁguration
C[t::s� ]sf is type-correct.
– If the rule application is a K rule, for any given conﬁguration C that is split
into a context C[]k and redex k that is a K term, a K rule only rewrites the
term k to a new term k � with the same type K . All K terms have sort K.
Thus, the ﬁnal result conﬁguration C[k � ]k is type-correct.
– If the rule application is a conﬁguration rule, for any given conﬁguration C,
applying a conﬁguration rule rewrites the term C to a new conﬁguration C �
that is type-correct.
Thus, evaluating a conﬁguration C in the type-checked theory Θ never results
in a type error.
A.6

IsaK and TransK Bisimulation Proof Sketches based on the
Isabelle Proofs

f
rl1f , ..., rln

t1
TransK

TransK

tq1
∈

∃ t3

t2

tq2
f
TransK(rl1f ), ..., TransK(rln
)

∈

t4

C1

rlc

TransK
C1q

C2
TransK

TransK(rlc )

C2q

Fig. 11: Soundness and Completeness of IsaK and TransK

Here we construct the relationship between IsaK and TransK. Fig. 11 describes the general soundness and completeness proof diagrams between them.
We have put a proof sketch in Appx. A.5 and the Isabelle formalization is at
https://github.com/liyili2/KtoIsabelle.
We ﬁrst look at the underlying system the proofs are based on. IsaK is
deﬁned in Isabelle, we also implemented TransK in Isabelle as well as a small
Isabelle system (Isab) in Isabelle so that we could capture the semantics of the
Isabelle theory translated from an IsaK one. If we assume that the generated
quotient type proofs are always valid in Isabelle, which is obvious, an Isabelle
theory translated by TransK only requires the soundness and completeness
proofs involving Isabelle datatypes/quotient types and inductive relations. The
translated inductive relations have the form as Fig. 10 (d), where every relation
is a binary one rewriting from a term t3 to a term t4 with a list of conditions

34

Liyi Li and Elsa L. Gunter

ϕ1 , ..., ϕn , such that they are all quantiﬁer-free. In addition, the deﬁnitions of
functions require the support of Hilbert’s choice operator. Thus, the rewriting
semantics of the Isabelle system (Isab) supporting these features is just a simple
typed λ-µ calculus with Hilbert’s choice operator and quotient types. Isab is
based on the λ-µ calculus developed by Matache et al. [31], and extended to
support the rewriting of the inductive relations described above and deﬁnitions
using Hilbert’s choice operator.
To prove the soundness/completeness between an IsaK theory and its
TransK translation into Isab, we have to prove the soundness and completeness of the functions rules separately from the K/conﬁguration rules (Fig. 11).
The problem is that every rule in IsaK has a conditional expression (having
type Bool ), and the rewrites of the Bool term can be inﬁnite. Additionally, the
function rules are translated to a deﬁnition of inductive relations in the big-step
format, and it can be inﬁfnite, too. The soundness and completeness for function rules have to assume that every rewrite of the function rule application on
the conditional expression terminates in a ﬁnite sequence whose length is n. In
addition, a function rule application in Isabelle deals with terms that are the
translated datatypes not quotient types. Thus, a function rule is applied to a
representative term in a given equivalence class, which is transitioned to another
term as a representative in the resulting equivalence class, as described by the
existential operation in the ﬁrst diagram of Fig. 11. The term t 3 is a representative of the class tq1 which is translated from the K term t1 . The soundness and
completeness of function rule applications are described below.
Before we show Theorem 2 that is restated as Theorem 5. We also need to
have the information in Fig. 9 that is restated as Fig. 9 here, as well as the
information in Fig. 10 that is restated as Fig. 10 below.
Theorem 5. (Soundness) In IsaK, assume that a sequence of function rules
rl1f , ..., rlnf applied to a term t1 terminates in n steps and results in term t2 , and
tq1 and tq2 are quotient type terms in Isab translated by TransK, there exists a
term t3 in tq1 transitioning through sequence of corresponding rule applications
TransK(rl1f ), ..., TransK(rlnf ) to term t4 , such that t4 is in the quotient type
class tq2 , which is a translation from t2 .
(Completeness) If there exist quotient type terms tq1 and tq2 , such that a
representative t3 of tq1 is transitioned to t4 in tq2 through a sequence of function
�
�
�
rule applications rl1f , ..., rlnf , and tq1 = TransK(t1 ), tq2 = TransK(t2 ), and rl1f =
�
TransK(rl1f ),..., rlnf = TransK(rlnf ), then t1 is transitioned to t2 through the
sequence of function rule applications rl1f , ..., rlnf .
We ﬁrst need to show the following lemma:
Lemma 1. For any two transformed terms t and t� in Isabelle, for any k and k � ,
such that t = TransK(k) and t� = TransK(k � ), k and k � in IsaK are equivalent
under the equational properties described in Fig. 7.
The proof of the lemma is based on an important assumption about K/IsaK.
One cannot deﬁne two terms in K/IsaK with the same constructor. Even if some-

A Complete Semantics of K and Its Translation to Isabelle

35

one makes two identical syntactic deﬁnitions in K, the current K implementation
helps map these two deﬁnitions with two distinct constructors. A consequence
of this assumption is that every term has a least sort in K/IsaK.
Proof. The proof is based on induction on the depth of the AST tree of a term
t. The base step is simple, and we ignore it here. The inductive step is divisible
into three cases:
– If the two terms t and t� are the same term, then the original terms k and
k � are also the same.
– If the two terms t and t� are quotient-equivalent involving only Set and Map
(like case (c) in Fig. 9), then k and k � are equivalent under the Set and Map
equational properties listed in Fig. 7.
– If the two terms t and t� are quotient-equivalent through cases (d) and (e) in
Fig. 9 (the line and diamond structures), then k and k � are the same term.
This is because the constructors serving explicit coercions are created in the
TransK function. The k and k � terms involve only subsort relations, without
needing coercions. Once the coercions are removed, the terms k and k � are
the same and have the same least sort, since every constructor in K/IsaK
is unique and has a unique least sort.
Next, we need to change the semantic rule in Fig. 4 a little. Speciﬁcally, we
need to change case (1) to by adding a number n representing the number of
steps an application of the rule can take. We need the step number to avoid the
termination proof of a given IsaK theory.
(1-a) true −→Θ true (1-b) false −→Θ false
0,f
0,f
(1-c)

c(kl) �= true

c(kl) �= false

c(kl) −→Θ
0,f error

rl ∈ Θ
m = match(rl, c(kl))
n �= 0
∗
t (−→Θ
(1-d) t = subs(m, cond(rl))
(n-1),f ) true
c(kl) −→Θ
n,f subs(m, right(rl))

With the above rule change and Lemma 1, we can now prove Theorem 5.
Proof. We ﬁrst show its soundness. The proof is rephrased as "for any number
n, if applying a rule rl to a term t terminates in n steps, and produces a result of
true or false, then applying TransK(rl) to the term TransK(t) also terminates
in n step with a result of True or False in Isabelle."
We abbreviate the transition that happens in Isabelle as −→tr,Θ
n,f .
We induct on the number n. The base step is when the term t is either true
or false (otherwise, it is an error). Trivially, when translating the two terms
in Isabelle, they are True or False values in Isabelle.
In the inductive step, for the n+1 step application, we have the assumption
that the rule-application case (1-d) above is a valid one for term t. It means that

36

Liyi Li and Elsa L. Gunter

a mapping m results from match(rl, t). We also have the translation of the rule
TransK(rl) and the term TransK(t). By a case analysis of the diﬀerent quotient
translation cases in Fig. 9, we can conclude that there is a term t� which is in
the same equivalence class as TransK(t), such that we can ﬁnd a mapping m� for
match(TransK(rl), TransK(t)); and every mapped term ti of meta-variable xi in
the mapping m� is in the same equivalence class as the term TransK(m(xi )). In
addition, translating the condition expression to true (through the transitions
∗
(−→Θ
(n+1 -1),f ) ) is valid because of the inductive hypothesis ( n+1 -1 ≤ n).
Thus, applying TransK(rl) to the term TransK(t) produces a valid term t� that
�
is in the equivalence class of t� , such that t −→Θ
(n+1),f t via the rule rl.
We then show its completeness. The proof is rephrased as "for any number n,
if we have a rule rl and a term t, and their translations TransK(rl) and TransK(t),
then if an application of TransK(rl) on the term TransK(t) terminates in n steps
with a result of True or False in Isabelle, then applying a rule rl to a term t
terminates in n steps, and produces a result of true or false."
We also induct on the number n. The base step is when the term TransK(t)
is either True or False in Isabelle (otherwise, it is an error). Trivially, there is
a term true or false in IsaK to match with the result term.
In the inductive step, for the n+1 step application, we have the assumption
that the rule application case (1-d) above is a valid one for the term TransK(t),
and the rule being applied is TransK(rl). This means that there is a mapping m
as a result of match(TransK(rl), TransK(t)). We need to show that there is also
a mapping m� as a result of match(rl, t). We show that there is a term t� which
is in the same equivalence class as t in IsaK by Lemma 1. By the lemma, there
is a mapping match(rl, t� ), such that every entry of m is the TransK translation
result of the entry with the same meta-variable in m� . Furthermore, the terms t
and t� are the same term because of the term normalization in IsaK introduced
in Section 3.2. Every input term for a rule application is assumed to be termnormalized. If two terms are in the same equivalence class, the normalized term
for all terms in the equivalence class is the same and it represents the canonical
��
form of the equivalence class. Thus, there is a step transition t −→Θ
(n+1),f t via
rule rl, and the translation of term t�� is in the same equivalence class as the
��
term t�� in the transition TransK(t) −→tr,Θ
(n+1),f t via rule match(TransK(rl).
We now show Theorem 3 that is restated as Theorem 6. We have a version of
the theorem based on the revised Theorem 5 above, where every Boolean term
is evaluated to a result of either true or false in n steps. Based on the revised
"termination in n steps" Theorem 5.
Theorem 6. (Soundness) In IsaK, assume that a conﬁguration C1 is transitioned to C2 through a K (or conﬁguration) rule rlc , and C1q is a quotient type
term translated from C1 , then C2q is translated from C2 by rule TransK(rlc ).
(Completeness) If there exist quotient type conﬁgurations C1q and C2q , such
that C1q transitions to C2q through a rule rlc� , C1q = TransK(C1 ), and rlc� =
TransK(rlc ), then C2 is transitioned from C1 by rule rlc and C2q = TransK(C2 ).
We have the proof of Theorem 6 as follows:

A Complete Semantics of K and Its Translation to Isabelle

37

Proof. We ﬁrst show its soundness. Given an IsaK theory Θ and conﬁguration
C, we do a structural induction on diﬀerent kinds of rules in Θ.
– If the application rule rl is a function rule, the conﬁguration is split into a
�
context C[]sf and a redex t::s, such that t −→Θ
f t , and the ﬁnal conﬁguration
� s
is C[t ]f . The ﬁnal conﬁguration is well-typed because of Theorem 4. We then
need to show that a translation of rl as TransK(rl) can also be applied to term
TransK(t), and it is transitioned to a term t� , which is in the same equivalence
class of the translation result of t� . This step of the proof is similar to the
one in proving Theorem 5, with the assumption that the rewrites of the
condition expression of the rl rule with term t produces a Boolean result of
true or false in n steps. We then need to show that the ﬁnal conﬁguration
from applying function rule TransK(rl) is in the same equivalence class as
the term TransK(C[t� ]sf ). To accomplish this, we have a lemma stating that
the application of an Isabelle definition to a term TransK(C) (as in the
case (b) translation result in Fig. 10) produces a term with the context C � []sf
and redex t� ::s, where t� and the hole in C � []sf also have the type s, t� is in the
same equivalence class as TransK(t� ), and C � [t� ]sf is in the same equivalence
class as the term TransK(C[t� ]sf ).
– If the application rule rl is a K rule, the conﬁguration is split into a context
C[]k and a redex k having sort K, such that applying rl to k results in k � , and
the ﬁnal conﬁguration is C[k � ]k . The ﬁnal conﬁguration is well-typed because
of Theorem 4. We then need to show that the translation of rl as TransK(rl)
can be applied to the term TransK(k) (like the k_rule translation in Fig. 10
(c)), and transition the term to a term k � that is in the equivalence class of
term TransK(k � ). This step of the proof is basically the same as in Theorem 5.
Finally, we need to show that the transition rule in Isabelle (like the ﬁrst
line of Fig. 10 (d)) can split the conﬁguration TransK(C) into a context C � []k
and redex k, such that k is in the same equivalence class as TransK(k), and
C � [k]k is in the same equivalence class as TransK(C); and we need to show
that the application of TransK(rl) to k results in k � , and C � [k � ]k is in the
same equivalence class as TransK(C[k � ]k ). The proof of this step is done by
a structural induction on any Isabelle term with the application of a special
inductive rule like the one in the ﬁrst line of Fig. 10 (d).
– If the application rule rl is a conﬁguration rule, then we only need to show
that when the conﬁguration is transitioned to C � via the rule, the translation
of C to TransK(C) is also transitioned to C � via the rule TransK(rl), such
that C � is in the same equivalence class as TransK(C � ). This is done by the
same strategy as the proof of Theorem 5.
We then show its completeness. The proof is to do a rule induction on the
top inductive relation listed in Fig. 10 (e), and then establish a sub-theorem by
doing an induction on the rules in Fig. 10 (d). There are three important cases
here:
– If the rule being applied is not the ﬁrst line of Fig. 10 (d), then the rule is
the translation of a conﬁguration rule rl in the given IsaK theory Θ. By a

38

Liyi Li and Elsa L. Gunter

similar proof strategy as that for proving Theorem 5, we can then show that
for any conﬁguration C = TransK(C), the application of TransK(rl) results
in a new conﬁguration C � ; the conﬁguration C is also transitioned to a new
conﬁguration C � via rule rl; and TransK(C � ) is in the same equivalence class
as C � .
– If the rule being applied is the ﬁrst line of Fig. 10 (d), then the rule is the
translation of K rule rl in the given IsaK theory Θ. Then, the given conﬁguration C = TransK(C) is split into a context C[]k and redex k. The rule
application of TransK(rl) to k results in a term k � . We need to show that
if k = TransK(k), then k transitions to k � via the K term transition part of
rule rl, such that k � is in the same equivalence class as term TransK(k � ). The
proof of the existence of the term uses the same strategy as the one in the
completeness proof of Theorem 5. Finally, we need to show that C is transitioned to C[k � ]k via rule rl, such that C[k � ]k is in the same equivalence class
as C[k � ]k . This proof is done by a similar strategy in proving the existence
of the context-redex combination in the soundness proof of an K rule above.
– If a given conﬁguration C contains an Isabelle deﬁnition t (like Fig. 10 (b)),
then the deﬁnition must be translated from a function constructor appearing
in the IsaK theory Θ. In this case, conﬁguration C is moved through several
transitions to a ﬁnal step C � such that the deﬁnition is replaced by the ground
term t� without any Isabelle deﬁnitions. In this case, C can be viewed as the
split of a context C[] and a redex t, such that C[t] = C and C[t� ] = C � .
We have shown inductively the following. For n steps of applications of the
inductive rule associated with the deﬁnition t, it is continuously translated
to t1 , ..., tn . For any rewrite from ti to ti+1 , the transition is through the
inductive rule TransK(rl), which is translated from a function rule rl in Θ.
Let ti = TransK(ti ), then ti transitions to ti+1 via the application of rule rl,
and TransK(ti+1 ) is in the same equivalence class as ti+1 . Thus, for any n step
computations of inductive rule applications for an Isabelle deﬁnition, there
are n step computations of function rule applications, and the ﬁnal term
tn computed in the IsaK system is translated into the same equivalence
class as the ﬁnal result term tn computed in the Isabelle system. Finally,
let t� = tn . We need to show that if C = TransK(C), t = TransK(t), and
t� = tn = TransK(tn ), then TransK(C[tn ]) is in the same equivalence class as
C[t� ]. The proof of this step is the same process as we have already performed
multiple times.
The above is the proof sketches of the Theorems 4, 5, and 6.

